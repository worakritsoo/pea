/* messages.svelte generated by Svelte v3.29.4 */
import {
	SvelteComponent,
	assign,
	binding_callbacks,
	compute_rest_props,
	create_slot,
	detach,
	element,
	exclude_internal_props,
	get_spread_update,
	init as init_1,
	insert,
	safe_not_equal,
	set_attributes,
	transition_in,
	transition_out,
	update_slot
} from "svelte/internal";

import { onMount, onDestroy, beforeUpdate, afterUpdate } from "svelte";
import { colorClasses } from "../shared/mixins";
import { classNames, noUndefinedProps } from "../shared/utils";
import { restProps } from "../shared/rest-props";
import { f7, f7ready } from "../shared/f7";

function create_fragment(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[21].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);
	let div_levels = [{ class: /*classes*/ ctx[1] }, restProps(/*$$restProps*/ ctx[2])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[22](div);
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[20], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				dirty & /*$$restProps*/ 4 && restProps(/*$$restProps*/ ctx[2])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[22](null);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","autoLayout","messages","newMessagesFirst","scrollMessages","scrollMessagesOnEdge","firstMessageRule","lastMessageRule","tailMessageRule","sameNameMessageRule","sameHeaderMessageRule","sameFooterMessageRule","sameAvatarMessageRule","customClassMessageRule","renderMessage","typing","init"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { class: className = undefined } = $$props;
	let { autoLayout = false } = $$props;
	let { messages = [] } = $$props;
	let { newMessagesFirst = false } = $$props;
	let { scrollMessages = true } = $$props;
	let { scrollMessagesOnEdge = true } = $$props;
	let { firstMessageRule = undefined } = $$props;
	let { lastMessageRule = undefined } = $$props;
	let { tailMessageRule = undefined } = $$props;
	let { sameNameMessageRule = undefined } = $$props;
	let { sameHeaderMessageRule = undefined } = $$props;
	let { sameFooterMessageRule = undefined } = $$props;
	let { sameAvatarMessageRule = undefined } = $$props;
	let { customClassMessageRule = undefined } = $$props;
	let { renderMessage = undefined } = $$props;
	let { typing = false } = $$props;
	let { init = true } = $$props;
	let el;
	let f7Messages;
	let childrenBeforeUpdated = null;

	onMount(() => {
		if (!init) return;

		f7ready(() => {
			f7Messages = f7.messages.create(noUndefinedProps({
				el,
				autoLayout,
				messages,
				newMessagesFirst,
				scrollMessages,
				scrollMessagesOnEdge,
				firstMessageRule,
				lastMessageRule,
				tailMessageRule,
				sameNameMessageRule,
				sameHeaderMessageRule,
				sameFooterMessageRule,
				sameAvatarMessageRule,
				customClassMessageRule,
				renderMessage
			}));

			if (typing) f7Messages.showTyping();
		});
	});

	beforeUpdate(() => {
		if (!init || !el) return;
		const children = el.children;
		if (!children) return;
		childrenBeforeUpdated = children.length;

		for (let i = 0; i < children.length; i += 1) {
			children[i].classList.add("message-appeared");
		}
	});

	afterUpdate(() => {
		if (!init) return;
		if (!el) return;
		const children = el.children;
		if (!children) return;
		const childrenAfterUpdated = children.length;

		for (let i = 0; i < children.length; i += 1) {
			if (!children[i].classList.contains("message-appeared")) {
				children[i].classList.add("message-appear-from-bottom");
			}
		}

		if (f7Messages && f7Messages.layout && autoLayout) {
			f7Messages.layout();
		}

		if (childrenBeforeUpdated !== childrenAfterUpdated && f7Messages && f7Messages.scroll && scrollMessages) {
			f7Messages.scroll();
		}
	});

	onDestroy(() => {
		if (f7Messages && f7Messages.destroy) {
			f7Messages.destroy();
			f7Messages = null;
		}
	});

	let initialWatched = false;

	function watchTyping(typingPassed) {
		if (!initialWatched) {
			initialWatched = true;
			return;
		}

		if (!f7Messages) return;
		if (typingPassed) f7Messages.showTyping(); else f7Messages.hideTyping();
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(27, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ("autoLayout" in $$new_props) $$invalidate(4, autoLayout = $$new_props.autoLayout);
		if ("messages" in $$new_props) $$invalidate(5, messages = $$new_props.messages);
		if ("newMessagesFirst" in $$new_props) $$invalidate(6, newMessagesFirst = $$new_props.newMessagesFirst);
		if ("scrollMessages" in $$new_props) $$invalidate(7, scrollMessages = $$new_props.scrollMessages);
		if ("scrollMessagesOnEdge" in $$new_props) $$invalidate(8, scrollMessagesOnEdge = $$new_props.scrollMessagesOnEdge);
		if ("firstMessageRule" in $$new_props) $$invalidate(9, firstMessageRule = $$new_props.firstMessageRule);
		if ("lastMessageRule" in $$new_props) $$invalidate(10, lastMessageRule = $$new_props.lastMessageRule);
		if ("tailMessageRule" in $$new_props) $$invalidate(11, tailMessageRule = $$new_props.tailMessageRule);
		if ("sameNameMessageRule" in $$new_props) $$invalidate(12, sameNameMessageRule = $$new_props.sameNameMessageRule);
		if ("sameHeaderMessageRule" in $$new_props) $$invalidate(13, sameHeaderMessageRule = $$new_props.sameHeaderMessageRule);
		if ("sameFooterMessageRule" in $$new_props) $$invalidate(14, sameFooterMessageRule = $$new_props.sameFooterMessageRule);
		if ("sameAvatarMessageRule" in $$new_props) $$invalidate(15, sameAvatarMessageRule = $$new_props.sameAvatarMessageRule);
		if ("customClassMessageRule" in $$new_props) $$invalidate(16, customClassMessageRule = $$new_props.customClassMessageRule);
		if ("renderMessage" in $$new_props) $$invalidate(17, renderMessage = $$new_props.renderMessage);
		if ("typing" in $$new_props) $$invalidate(18, typing = $$new_props.typing);
		if ("init" in $$new_props) $$invalidate(19, init = $$new_props.init);
		if ("$$scope" in $$new_props) $$invalidate(20, $$scope = $$new_props.$$scope);
	};

	let classes;

	$$self.$$.update = () => {
		$: $$invalidate(1, classes = classNames(className, "messages", colorClasses($$props)));

		if ($$self.$$.dirty & /*typing*/ 262144) {
			$: watchTyping(typing);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		el,
		classes,
		$$restProps,
		className,
		autoLayout,
		messages,
		newMessagesFirst,
		scrollMessages,
		scrollMessagesOnEdge,
		firstMessageRule,
		lastMessageRule,
		tailMessageRule,
		sameNameMessageRule,
		sameHeaderMessageRule,
		sameFooterMessageRule,
		sameAvatarMessageRule,
		customClassMessageRule,
		renderMessage,
		typing,
		init,
		$$scope,
		slots,
		div_binding
	];
}

class Messages extends SvelteComponent {
	constructor(options) {
		super();

		init_1(this, options, instance, create_fragment, safe_not_equal, {
			class: 3,
			autoLayout: 4,
			messages: 5,
			newMessagesFirst: 6,
			scrollMessages: 7,
			scrollMessagesOnEdge: 8,
			firstMessageRule: 9,
			lastMessageRule: 10,
			tailMessageRule: 11,
			sameNameMessageRule: 12,
			sameHeaderMessageRule: 13,
			sameFooterMessageRule: 14,
			sameAvatarMessageRule: 15,
			customClassMessageRule: 16,
			renderMessage: 17,
			typing: 18,
			init: 19
		});
	}
}

export default Messages;